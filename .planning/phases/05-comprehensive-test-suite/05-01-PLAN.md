---
phase: 05-comprehensive-test-suite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/backend/test/unit/password.test.ts
  - packages/backend/test/unit/sanitize.test.ts
  - packages/backend/test/unit/auth.service.test.ts
  - packages/backend/test/unit/job-matching.test.ts
autonomous: true
requirements:
  - TEST-02

must_haves:
  truths:
    - "Running npm test in packages/backend executes unit tests for password hashing, XSS sanitization, auth signup/login, and job matching"
    - "All unit tests pass — hashPassword produces PBKDF2 format, verifyPassword validates correctly, isLegacyHash detects bcrypt"
    - "Sanitize tests confirm XSS payloads are stripped from rich-text fields and plain-text fields are trimmed"
    - "Auth service tests confirm signup creates user+session and login validates credentials against D1"
  artifacts:
    - path: "packages/backend/test/unit/password.test.ts"
      provides: "Password utility unit tests"
      contains: "hashPassword"
    - path: "packages/backend/test/unit/sanitize.test.ts"
      provides: "XSS sanitization unit tests"
      contains: "sanitizeField"
    - path: "packages/backend/test/unit/auth.service.test.ts"
      provides: "Auth service unit tests"
      contains: "signup"
    - path: "packages/backend/test/unit/job-matching.test.ts"
      provides: "Job matching unit tests"
      contains: "buildUserContext"
  key_links:
    - from: "packages/backend/test/unit/password.test.ts"
      to: "packages/backend/src/utils/password.ts"
      via: "direct import"
      pattern: "import.*password"
    - from: "packages/backend/test/unit/auth.service.test.ts"
      to: "packages/backend/src/services/auth.service.ts"
      via: "direct import + D1 env from cloudflare:test"
      pattern: "import.*auth\\.service"
---

<objective>
Create backend unit tests for auth, password utilities, XSS sanitization, and job matching services.

Purpose: Satisfy TEST-02 — unit tests for auth, resume parsing, and job matching services that pass when running `npm test` in the backend workspace.
Output: 4 test files in `packages/backend/test/unit/` covering password utils, sanitization, auth service, and job matching logic.
</objective>

<execution_context>
@/home/carl/.claude/get-shit-done/workflows/execute-plan.md
@/home/carl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-comprehensive-test-suite/05-RESEARCH.md

@packages/backend/vitest.config.mts
@packages/backend/test/smoke.test.ts
@packages/backend/src/utils/password.ts
@packages/backend/src/utils/sanitize.ts
@packages/backend/src/services/auth.service.ts
@packages/backend/src/services/job-matching.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create password utility and sanitization unit tests</name>
  <files>
    packages/backend/test/unit/password.test.ts
    packages/backend/test/unit/sanitize.test.ts
  </files>
  <action>
    Create `packages/backend/test/unit/password.test.ts`:
    - Import `hashPassword`, `verifyPassword`, `isLegacyHash` from `../../src/utils/password`
    - Test `hashPassword('mypassword')` produces a string matching `/^pbkdf2:100000:/`
    - Test `verifyPassword('mypassword', hash)` returns `true` for correct password
    - Test `verifyPassword('wrong', hash)` returns `false`
    - Test `isLegacyHash('$2b$10$somevalue')` returns `true`
    - Test `isLegacyHash('pbkdf2:100000:aabb:ccdd')` returns `false`
    - Test that two calls to `hashPassword` with the same password produce different hashes (random salt)

    Create `packages/backend/test/unit/sanitize.test.ts`:
    - Import `sanitizeField` (or the sanitization function) from `../../src/utils/sanitize`
    - Read the actual sanitize.ts file first to confirm the exact export names and signatures
    - Test that `<script>alert(1)</script>` is stripped from rich-text input
    - Test that plain-text fields are trimmed and have maxLength applied
    - Test that normal text passes through unchanged
    - Test edge cases: empty string, null/undefined if applicable, very long input

    Both files use `import { describe, it, expect } from 'vitest'`. These run in Workers runtime via vitest-pool-workers — crypto.subtle is available natively for password tests.
  </action>
  <verify>
    Run `cd packages/backend && npx vitest run test/unit/password.test.ts test/unit/sanitize.test.ts` — all tests pass.
  </verify>
  <done>Password utility tests verify PBKDF2 hashing, verification, and legacy detection. Sanitization tests verify XSS stripping and text trimming.</done>
</task>

<task type="auto">
  <name>Task 2: Create auth service and job matching unit tests</name>
  <files>
    packages/backend/test/unit/auth.service.test.ts
    packages/backend/test/unit/job-matching.test.ts
  </files>
  <action>
    Create `packages/backend/test/unit/auth.service.test.ts`:
    - Import `env` from `cloudflare:test` (provides real D1 binding)
    - Import `signup`, `login` (and any other exports) from `../../src/services/auth.service`
    - Read auth.service.ts first to confirm exact function signatures and return types
    - Test signup: call `signup(env, uniqueEmail, 'password123')` — expect it returns user object with the email and a session ID
    - Test signup duplicate: call signup twice with same email — expect second call throws or returns error
    - Test login: signup first, then call `login(env, email, 'password123')` — expect success with session
    - Test login wrong password: expect failure/throw
    - Use unique emails per test: `test-${Date.now()}-${Math.random()}@example.com` to avoid duplicate constraint errors (singleWorker: true means D1 persists between tests)

    Create `packages/backend/test/unit/job-matching.test.ts`:
    - Read `job-matching.service.ts` first to identify testable pure functions (e.g., `buildUserContext`, cache key generation, score calculation)
    - Import `env` from `cloudflare:test` if D1 is needed
    - Test any pure logic functions that don't require AI binding
    - For functions requiring AI binding, skip with a comment explaining AI mock would be needed
    - Test cache key generation if exported (should include profile version)
    - Test `buildUserContext` if it accepts env + userId — seed a user first via D1 direct insert or signup

    IMPORTANT: Do NOT mock the Workers runtime. Use real crypto.subtle, real D1 from `cloudflare:test`. Use unique identifiers per test to avoid D1 state collisions.
  </action>
  <verify>
    Run `cd packages/backend && npx vitest run test/unit/` — all unit tests pass including smoke.test.ts.
  </verify>
  <done>Auth service tests verify signup creates user+session, login validates credentials, duplicate emails rejected. Job matching tests verify any testable pure logic.</done>
</task>

</tasks>

<verification>
Run `cd packages/backend && npm test` — all tests pass (smoke + unit tests).
</verification>

<success_criteria>
- 4 unit test files exist in `packages/backend/test/unit/`
- `npm test` in backend workspace runs all tests and passes
- Password, sanitization, auth, and job matching logic is covered
</success_criteria>

<output>
After completion, create `.planning/phases/05-comprehensive-test-suite/05-01-SUMMARY.md`
</output>
