---
phase: 04-performance-graceful-degradation
plan: 04
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - packages/backend/src/services/db.service.ts
  - packages/backend/src/routes/jobs.ts
  - packages/frontend/src/lib/api-client.ts
  - migrations/0012_cursor_pagination.sql
autonomous: true
requirements:
  - PERF-02

must_haves:
  truths:
    - "Job listings API returns paginated results with a cursor token"
    - "A frontend request for page 2 uses the cursor from page 1 and returns the correct next batch without duplicates"
    - "First page request (no cursor) returns the first N jobs ordered by posted_date DESC"
  artifacts:
    - path: "packages/backend/src/services/db.service.ts"
      provides: "getJobs with cursor-based keyset pagination"
      contains: "decodeCursor"
    - path: "packages/backend/src/routes/jobs.ts"
      provides: "Jobs route returning nextCursor and hasMore in response"
      contains: "nextCursor"
    - path: "migrations/0012_cursor_pagination.sql"
      provides: "Index on jobs(posted_date DESC, id DESC) for efficient keyset queries"
      contains: "idx_jobs_posted_date"
    - path: "packages/frontend/src/lib/api-client.ts"
      provides: "Updated response type for jobs API including cursor fields"
      contains: "nextCursor"
  key_links:
    - from: "packages/backend/src/routes/jobs.ts"
      to: "packages/backend/src/services/db.service.ts"
      via: "getJobs now accepts cursor parameter"
      pattern: "cursor"
    - from: "packages/frontend/src/lib/api-client.ts"
      to: "packages/backend/src/routes/jobs.ts"
      via: "Updated response type includes nextCursor and hasMore"
      pattern: "nextCursor|hasMore"
---

<objective>
Add cursor-based pagination to the job listings API with appropriate database index.

Purpose: The jobs API currently returns ALL matching jobs with no limit — this grows unbounded as jobs accumulate. Cursor-based (keyset) pagination provides stable page boundaries without the row-duplication issues of OFFSET pagination, and the composite index on `(posted_date DESC, id DESC)` ensures efficient query execution.

Output: D1 migration adding composite index, `getJobs` with cursor/limit parameters, jobs route returning `{ jobs, nextCursor, hasMore }`, updated frontend TypeScript types.
</objective>

<execution_context>
@/home/carl/.claude/get-shit-done/workflows/execute-plan.md
@/home/carl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-performance-graceful-degradation/04-RESEARCH.md
@.planning/phases/04-performance-graceful-degradation/04-01-SUMMARY.md

@packages/backend/src/services/db.service.ts
@packages/backend/src/routes/jobs.ts
@packages/frontend/src/lib/api-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cursor pagination to jobs DB query and route</name>
  <files>
    packages/backend/src/services/db.service.ts
    packages/backend/src/routes/jobs.ts
    migrations/0012_cursor_pagination.sql
  </files>
  <action>
1. Create migration file `migrations/0012_cursor_pagination.sql`:
   ```sql
   CREATE INDEX IF NOT EXISTS idx_jobs_posted_date ON jobs(posted_date DESC, id DESC);
   ```
   Check existing migration files to determine the correct migration number (it may not be 0012 — use the next available number after the last existing migration). Also check if `posted_date` is a column that exists — the research confirms it does from `0001_initial_schema.sql`.

2. Add cursor encoding/decoding utility functions in `db.service.ts` (or a utils file if more appropriate):
   ```typescript
   function encodeCursor(job: { posted_date: number; id: string }): string {
     return btoa(JSON.stringify({ posted_date: job.posted_date, id: job.id }));
   }
   function decodeCursor(cursor: string): { posted_date: number; id: string } | null {
     try { return JSON.parse(atob(cursor)); } catch { return null; }
   }
   ```

3. Modify the `getJobs` function in `db.service.ts` to accept optional `cursor` and `limit` parameters (default limit = 20). The function currently builds a SQL query dynamically with filters. Add cursor-based WHERE conditions:
   - Without cursor: Add `ORDER BY posted_date DESC, id DESC LIMIT ?` to existing query
   - With cursor: Add `AND (posted_date < ? OR (posted_date = ? AND id < ?))` BEFORE the ORDER BY, using values from `decodeCursor(cursor)`. **PITFALL:** Wrap the cursor condition in parentheses to avoid interaction with other AND conditions.

4. Update the return type of `getJobs` to include pagination metadata:
   ```typescript
   return {
     jobs: results,
     nextCursor: results.length === limit ? encodeCursor(results[results.length - 1]) : null,
     hasMore: results.length === limit
   };
   ```

5. In `jobs.ts` route handler (GET /api/jobs), read `cursor` and `limit` from query params: `c.req.query('cursor')`, `c.req.query('limit')`. Parse limit as integer with default 20, max 100. Pass to `getJobs`. Return the full paginated response `{ jobs, nextCursor, hasMore }`.

6. Check if any other callers of `getJobs` exist (e.g., recommendations, admin). If so, ensure they still work — they may need to be updated to handle the new return shape, or `getJobs` can return the old shape when no cursor/limit is provided.

**PITFALL WARNING (from research):** The frontend currently destructures `{ jobs }` from the response. The new fields (`nextCursor`, `hasMore`) are additive, so existing destructuring won't break. But TypeScript types must be updated.
  </action>
  <verify>
- Migration file exists with the composite index
- `grep "decodeCursor\|encodeCursor" packages/backend/src/services/db.service.ts` shows cursor utilities
- `grep "nextCursor\|hasMore" packages/backend/src/routes/jobs.ts` shows pagination response fields
- `cd packages/backend && npx tsc --noEmit` compiles without errors
  </verify>
  <done>Jobs API returns paginated results with cursor token; composite index supports efficient keyset queries; default page size is 20</done>
</task>

<task type="auto">
  <name>Task 2: Update frontend types for paginated jobs response</name>
  <files>
    packages/frontend/src/lib/api-client.ts
  </files>
  <action>
1. In `api-client.ts`, find the response type for the jobs API call (likely in `getJobs` method or its return type). Update it to include the new pagination fields:
   ```typescript
   // Add to existing response type
   nextCursor: string | null;
   hasMore: boolean;
   ```

2. If the `getJobs` method in api-client passes through query params, add `cursor` as an optional parameter:
   ```typescript
   getJobs(filters?: JobFilters & { cursor?: string; limit?: number }): Promise<{ jobs: Job[]; nextCursor: string | null; hasMore: boolean }>
   ```

3. Check if any shared types package (`packages/shared`) has a type for the jobs API response. If so, update there instead of (or in addition to) api-client.ts.

4. Do NOT implement infinite scroll or "Load More" UI — that is out of scope for this phase. The frontend should continue to display whatever jobs are returned. The pagination infrastructure is the deliverable; UI for paging can be added later.

5. Verify that all existing callers of `getJobs` in the frontend still compile. The new fields are additive (existing `{ jobs }` destructuring still works), but TypeScript may flag type mismatches if strict mode catches the expanded response shape.
  </action>
  <verify>
- `grep "nextCursor" packages/frontend/src/lib/api-client.ts` returns a match
- `cd packages/frontend && npx tsc --noEmit` compiles without errors (or check root-level tsc)
- Existing components that use getJobs still compile (no breaking type changes)
  </verify>
  <done>Frontend TypeScript types updated for paginated jobs response; existing code compiles cleanly; cursor parameter available for future "Load More" implementation</done>
</task>

</tasks>

<verification>
- TypeScript compiles cleanly across all workspaces
- Migration file creates composite index on jobs(posted_date DESC, id DESC)
- Jobs API accepts optional cursor and limit query params
- Response includes nextCursor (string|null) and hasMore (boolean)
- First page (no cursor) returns first 20 jobs by posted_date DESC
- Existing frontend code still compiles and functions
</verification>

<success_criteria>
- Job listings API returns paginated results with cursor token
- Default page size is 20, configurable up to 100
- Cursor encodes posted_date + id for stable keyset pagination
- Frontend types updated; no TypeScript errors
- No pagination UI changes (infrastructure only)
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance-graceful-degradation/04-04-SUMMARY.md`
</output>
