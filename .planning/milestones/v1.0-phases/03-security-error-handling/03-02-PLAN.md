---
phase: 03-security-error-handling
plan: 02
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - packages/backend/src/services/auth.service.ts
  - src/app/lib/auth.ts
  - packages/backend/src/services/resume.service.ts
  - src/app/api/resume-upload.ts
  - src/app/pages/Profile.tsx
  - packages/frontend/src/pages/Resume.tsx
  - packages/frontend/src/components/Education.tsx
autonomous: true
requirements:
  - SEC-02
  - SEC-05

must_haves:
  truths:
    - "Injecting <script>alert(1)</script> into a resume upload does not result in that string being stored or reflected unescaped"
    - "AI-parsed resume fields are sanitized with max length limits before database storage"
    - "New password hashes use PBKDF2 via crypto.subtle instead of bcryptjs"
    - "Existing bcryptjs-hashed passwords still verify correctly and are re-hashed to PBKDF2 on successful login"
    - "Frontend components that render resume fields use React default text rendering (no raw HTML injection), satisfying render-time sanitization"
  artifacts:
    - path: "packages/backend/src/utils/sanitize.ts"
      provides: "XSS sanitization utility with js-xss and max length enforcement"
      exports: ["sanitizeField", "sanitizeResumeData"]
    - path: "packages/backend/src/utils/password.ts"
      provides: "PBKDF2 password hashing with bcryptjs backward compatibility"
      exports: ["hashPassword", "verifyPassword"]
    - path: "src/app/lib/password.ts"
      provides: "PBKDF2 password hashing for rwsdk app with bcryptjs backward compatibility"
      exports: ["hashPassword", "verifyPassword"]
  key_links:
    - from: "packages/backend/src/services/resume.service.ts"
      to: "packages/backend/src/utils/sanitize.ts"
      via: "sanitizeResumeData called before DB insert"
      pattern: "sanitizeResumeData"
    - from: "src/app/api/resume-upload.ts"
      to: "sanitize utility"
      via: "sanitizeResumeData called before returning parsed resume and before saving"
      pattern: "sanitizeResumeData"
    - from: "packages/backend/src/services/auth.service.ts"
      to: "packages/backend/src/utils/password.ts"
      via: "hashPassword/verifyPassword replace direct bcryptjs calls"
      pattern: "hashPassword|verifyPassword"
---

<objective>
Sanitize AI-parsed resume fields with js-xss before storage and replace bcryptjs password hashing with PBKDF2 via crypto.subtle in both auth modules.

Purpose: Close SEC-02 (XSS sanitization of AI output) and SEC-05 (bcryptjs CPU safety in Workers). These are the two security requirements that need new npm dependencies and careful migration logic.

Output: Resume data is sanitized at write time with an allowed HTML subset and max length caps. Render-time sanitization is verified (defense in depth per user decision). Password hashing uses Workers-native PBKDF2 with transparent bcryptjs backward compatibility for existing users.
</objective>

<execution_context>
@/home/carl/.claude/get-shit-done/workflows/execute-plan.md
@/home/carl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-security-error-handling/03-RESEARCH.md

@packages/backend/src/services/auth.service.ts
@src/app/lib/auth.ts
@packages/backend/src/services/resume.service.ts
@src/app/api/resume-upload.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: AI resume field sanitization with js-xss</name>
  <files>
    packages/backend/src/utils/sanitize.ts
    packages/backend/src/services/resume.service.ts
    src/app/api/resume-upload.ts
  </files>
  <action>
**Install js-xss:**
Run `npm install xss --workspace=packages/backend`. Also check if the rwsdk app (root src/) needs it installed at root level — if `src/app/api/resume-upload.ts` imports from packages/backend it may already be available, otherwise run `npm install xss` at root.

**Create `packages/backend/src/utils/sanitize.ts`:**

Create a sanitization utility using js-xss with the following configuration:

Whitelist: `b`, `strong`, `i`, `em`, `u`, `s`, `h1`, `h2`, `h3`, `h4`, `p`, `br`, `ul`, `ol`, `li` (NO script, iframe, form, input, a, img, style, event handlers).

Options: `stripIgnoreTag: true`, `stripIgnoreTagBody: ['script', 'style', 'iframe']`.

Export `sanitizeField(value: string, maxLength: number): string` — runs xss() then truncates.

Export `sanitizeResumeData(data: ParsedResume): ParsedResume` — applies sanitizeField to each field with these max lengths per the research:
- name: 200, email: 255, phone: 50, location: 200, headline: 500, summary: 5000
- workExperience[].company: 300, title: 300, description: 3000, achievements[]: 1000 each
- education[].school: 300
- skills[]: 100 each, certifications[].name: 300, languages[]: 100 each

For structured string fields (name, email, phone, location), apply `trim()` and maxLength only — no HTML expected. For rich text fields (summary, description, achievements), apply xss() sanitization AND maxLength.

**Apply in `packages/backend/src/services/resume.service.ts`:**
Find where ParsedResume data is saved to DB (the `saveResume()` or equivalent function). Call `sanitizeResumeData(parsedResume)` before the DB insert. Import from `../utils/sanitize.ts`.

**Apply in `src/app/api/resume-upload.ts`:**
The rwsdk app has two sanitization points (defense in depth per user decision):
1. After `parseResumeWithAI()` returns — sanitize before returning to client in `handleResumeUpload`
2. In `handleResumeConfirm` — sanitize the client-submitted parsedResume AGAIN before calling `saveParsedResumeToProfile()`, since the client could have modified the data

Import the sanitize utility — if the rwsdk app can import from packages/backend, use that path. Otherwise, create a parallel utility at `src/app/lib/sanitize.ts` with the same logic.

IMPORTANT: This is defense in depth (user locked decision). Sanitize at BOTH storage time AND before returning to client. Do not skip either point.
  </action>
  <verify>
Run `npx tsc --noEmit` in packages/backend. Verify sanitization is wired:
- `grep -rn "sanitizeResumeData" packages/backend/src/ src/app/`
- `grep -rn "import.*xss" packages/backend/src/ src/app/`
  </verify>
  <done>
AI-parsed resume fields are sanitized with js-xss (allowed HTML subset preserved, scripts/iframes stripped) and max length caps before storage. Both the backend and rwsdk resume paths sanitize data. Injecting `<script>alert(1)</script>` into a resume field results in the tag being stripped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace bcryptjs with PBKDF2 in both auth modules</name>
  <files>
    packages/backend/src/utils/password.ts
    packages/backend/src/services/auth.service.ts
    src/app/lib/auth.ts
    src/app/lib/password.ts
  </files>
  <action>
**Create `packages/backend/src/utils/password.ts`:**

Implement two functions using Web Crypto API (built into Workers, no npm install needed):

`hashPassword(password: string): Promise<string>` — generates 16 random bytes salt via `crypto.getRandomValues`, imports key via `crypto.subtle.importKey('raw', ...)`, derives 256 bits via `crypto.subtle.deriveBits` with PBKDF2 (100,000 iterations, SHA-256). Returns format: `pbkdf2:100000:{saltHex}:{hashHex}`.

`verifyPassword(password: string, stored: string): Promise<boolean>` — checks hash format:
- If `stored.startsWith('$2b$') || stored.startsWith('$2a$')`: legacy bcryptjs hash — use `bcryptjs.compare()` for verification ONLY (import bcryptjs dynamically). Return true/false.
- If `stored.startsWith('pbkdf2:')`: parse iterations, salt, hash from the colon-delimited format, re-derive, compare.

This keeps bcryptjs as a verification-only dependency for migration. New hashes always use PBKDF2.

**Create `src/app/lib/password.ts`:**
Same implementation as above for the rwsdk app. The Web Crypto API is available in both Workers runtimes.

**Update `packages/backend/src/services/auth.service.ts`:**
Replace all `bcrypt.hash()` calls with `hashPassword()` from `../utils/password.ts`. Replace all `bcrypt.compare()` calls with `verifyPassword()`. Add migration: on successful login where verifyPassword detected a bcryptjs hash (stored starts with `$2b$`), re-hash with `hashPassword()` and update the user's password_hash in D1. This is lazy migration — all users get migrated over time without a forced password reset.

**Update `src/app/lib/auth.ts`:**
Same replacements — `hashPassword()` and `verifyPassword()` from `./password.ts`. Same lazy migration on login.

IMPORTANT (Pitfall 3): Both auth modules MUST be updated. Do not update only one. IMPORTANT (Pitfall 6): The backward compatibility for bcryptjs hashes is critical — existing users must still be able to log in.
  </action>
  <verify>
Run `npx tsc --noEmit` in packages/backend. Verify:
- `grep -rn "hashPassword\|verifyPassword" packages/backend/src/services/auth.service.ts src/app/lib/auth.ts`
- `grep -rn "pbkdf2" packages/backend/src/utils/password.ts src/app/lib/password.ts`
- Confirm bcryptjs is only used in verifyPassword for legacy hash detection: `grep -rn "bcrypt" packages/backend/src/ src/app/lib/`
  </verify>
  <done>
Both auth modules hash new passwords with PBKDF2 via crypto.subtle. Existing bcryptjs hashes verify correctly and are lazily re-hashed to PBKDF2 on successful login. bcryptjs is retained only for verification of legacy hashes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Audit and verify render-time sanitization (defense in depth)</name>
  <files>
    src/app/pages/Profile.tsx
    packages/frontend/src/pages/Resume.tsx
    packages/frontend/src/components/Education.tsx
  </files>
  <action>
**Context:** The user locked "Sanitize at both storage time AND render time (defense in depth)." Task 1 covers write-time sanitization. This task covers the render-time half.

**Audit all frontend components that render resume fields:**

Scan these files for how resume data (name, email, summary, workExperience, education, skills, etc.) is rendered:
- `src/app/pages/Profile.tsx` (rwsdk app — displays parsed resume data)
- `packages/frontend/src/pages/Resume.tsx` (frontend package — resume display)
- `packages/frontend/src/pages/Profile.tsx` (frontend package — profile with resume fields)
- `packages/frontend/src/components/Education.tsx` (education entries)
- Any other components found via `grep -rn "resume\|workExperience\|ParsedResume" src/app/ packages/frontend/src/`

**For each component, verify one of two conditions:**

1. **React default text rendering** (JSX expressions like `{resume.summary}`, `{item.company}`): React automatically escapes HTML entities in text content. This IS sufficient render-time sanitization — any `<script>` tags stored in the DB would render as literal text, not executed HTML. Add a code comment at the top of the component:
   ```typescript
   // SECURITY: Resume fields rendered via React JSX expressions — React auto-escapes HTML entities (render-time sanitization)
   ```

2. **Raw HTML rendering** (if any component uses `dangerouslySetInnerHTML` or similar patterns to render resume fields): This would be a security gap. If found, wrap the content with js-xss sanitization before rendering:
   ```typescript
   import { sanitizeField } from '../utils/sanitize'; // or appropriate import path
   // Then: dangerouslySetInnerHTML={{ __html: sanitizeField(resume.summary, 5000) }}
   ```

**Expected outcome:** Based on codebase analysis, NO components currently use raw HTML injection for resume fields — all use React's default JSX text rendering. The task should confirm this and add the security comments documenting that React's escaping satisfies the render-time sanitization requirement.

IMPORTANT: If you DO find raw HTML rendering of resume fields, that is a security gap — fix it with sanitization, do not just add a comment.
  </action>
  <verify>
Verify no raw HTML rendering of resume data:
- `grep -rn "dangerouslySetInnerHTML" src/app/ packages/frontend/src/` should return no matches involving resume fields
- `grep -rn "SECURITY.*render-time" src/app/pages/Profile.tsx packages/frontend/src/pages/Resume.tsx packages/frontend/src/components/Education.tsx` should show the added comments
  </verify>
  <done>
All frontend components that render resume fields are confirmed to use React's default text rendering (auto-escaping). Security comments document this as satisfying the render-time half of the defense-in-depth sanitization strategy. No raw HTML injection of resume data exists in the codebase.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in packages/backend
2. js-xss is installed and sanitizeResumeData is called in both resume processing paths
3. PBKDF2 hashPassword/verifyPassword exist in both packages
4. bcryptjs is only imported for legacy hash verification, not for new hashing
5. Lazy migration logic re-hashes bcryptjs passwords on login
6. All frontend components rendering resume fields are audited — React auto-escaping confirmed as render-time sanitization
</verification>

<success_criteria>
- `<script>alert(1)</script>` in a resume field is stripped to empty string after sanitization
- New password registrations produce `pbkdf2:100000:...` format hashes
- Existing `$2b$...` bcryptjs hashes still verify correctly
- TypeScript compiles without errors in both packages
</success_criteria>

<output>
After completion, create `.planning/phases/03-security-error-handling/03-02-SUMMARY.md`
</output>
