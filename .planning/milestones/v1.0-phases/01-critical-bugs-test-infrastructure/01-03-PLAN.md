---
phase: 01-critical-bugs-test-infrastructure
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/types/application.ts
  - packages/frontend/src/pages/Applications.tsx
  - migrations/0001_initial_schema.sql
autonomous: false
requirements:
  - BUG-02

must_haves:
  truths:
    - "Application status values displayed in the UI match exactly the values stored in the database"
    - "The ApplicationStatus TypeScript type lists only values that are valid in the database"
    - "Existing live data has been audited and no unexpected status values exist (or they have been normalized)"
  artifacts:
    - path: "packages/shared/src/types/application.ts"
      provides: "ApplicationStatus type aligned with actual database values"
      contains: "ApplicationStatus"
    - path: "migrations/0001_initial_schema.sql"
      provides: "Schema comment updated to reflect actual valid status values"
      contains: "status"
  key_links:
    - from: "packages/shared/src/types/application.ts"
      to: "packages/frontend/src/pages/Applications.tsx"
      via: "ApplicationStatus import used for column rendering"
      pattern: "import.*ApplicationStatus"
    - from: "packages/shared/src/types/application.ts"
      to: "migrations/0001_initial_schema.sql"
      via: "TypeScript type must match SQL schema comment"
      pattern: "ApplicationStatus"
---

<objective>
Audit the live D1 database for application status values, then align the TypeScript type and UI with the actual database state to fix the schema mismatch (BUG-02).

Purpose: The UI displays status columns based on the TypeScript type (6 values including "screening"), but the database schema comment only lists 5 values. If they are out of sync, users see incorrect application groupings.
Output: ApplicationStatus type matches verified database values; schema comment is accurate.
</objective>

<execution_context>
@/home/carl/.claude/get-shit-done/workflows/execute-plan.md
@/home/carl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-critical-bugs-test-infrastructure/01-RESEARCH.md
@packages/shared/src/types/application.ts
@packages/frontend/src/pages/Applications.tsx
@migrations/0001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit live D1 for actual status values and align types</name>
  <files>
    packages/shared/src/types/application.ts
    migrations/0001_initial_schema.sql
  </files>
  <action>
1. Run the audit query against the REMOTE D1 database to discover what status values actually exist:
   ```bash
   npx wrangler d1 execute gethiredpoc-db \
     --command "SELECT DISTINCT status, COUNT(*) as count FROM applications GROUP BY status ORDER BY count DESC" \
     --remote
   ```

   Record the output. This tells us exactly which values are in production.

2. Also run against the LOCAL D1 to see if there is local test data:
   ```bash
   npx wrangler d1 execute gethiredpoc-db \
     --command "SELECT DISTINCT status, COUNT(*) as count FROM applications GROUP BY status ORDER BY count DESC" \
     --local
   ```

3. **Decision tree based on audit results:**

   **Case A: Only the 5 original values exist (saved, applied, interview, offer, rejected) — no "screening" rows:**
   - The `screening` value was added to the TypeScript type but never used in practice.
   - Two valid approaches:
     a. Keep `screening` in the type (it is a valid future status) and update the DB schema comment to include it.
     b. Remove `screening` from the type to match the original schema comment.
   - **Choose option (a)**: Keep `screening`. The UI already supports it, the column is TEXT (no constraint), and removing it would be a regression if any user has manually set it. Update the schema comment in `migrations/0001_initial_schema.sql` to list all 6 values including `screening`.

   **Case B: `screening` rows exist in production:**
   - Both sources already agree. Update the schema comment to include `screening`. No data migration needed.

   **Case C: Unexpected values exist (e.g., "phone-screen", "Phone Screen", null):**
   - Write a data normalization migration. Create `migrations/0002_normalize_status.sql` with UPDATE statements to map unexpected values to valid ones.
   - Then update the schema comment.

4. Update the comment in `migrations/0001_initial_schema.sql` for the `status` column to list the verified set of valid values (likely all 6: saved, applied, screening, interview, offer, rejected).

5. Verify `packages/shared/src/types/application.ts` `ApplicationStatus` type matches the verified values. If it already does (it currently lists all 6), no change needed to this file.

6. Verify `packages/frontend/src/pages/Applications.tsx` uses `ApplicationStatus` from the shared package — if it does, it is automatically aligned.
  </action>
  <verify>
1. Audit query output documented (what values exist in production)
2. `ApplicationStatus` type in shared/src/types/application.ts matches verified DB values
3. Schema comment in migrations/0001_initial_schema.sql lists all valid values
4. `npx tsc --noEmit -p packages/frontend/tsconfig.json` passes
5. `npx tsc --noEmit -p packages/shared/tsconfig.json` passes (if tsconfig exists)
  </verify>
  <done>Live D1 data audited. ApplicationStatus TypeScript type matches the actual database values. Schema comment updated to reflect the verified valid set.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify status alignment is correct</name>
  <files>packages/shared/src/types/application.ts</files>
  <action>
Present the audit results and alignment changes to the user for verification.
What was built: Audited the live D1 database for application status values and aligned the TypeScript type and SQL schema comment to match reality.
How to verify:
1. Review the audit query output (printed in Task 1) — confirm the values make sense
2. Check that `packages/shared/src/types/application.ts` ApplicationStatus matches the audit results
3. Check that the schema comment in migrations reflects the same values
4. If a normalization migration was created (Case C), review the UPDATE statements before they are applied
Resume signal: Type "approved" if the alignment is correct, or describe any issues.
  </action>
  <verify>User confirms the alignment is correct by typing "approved".</verify>
  <done>User has verified that ApplicationStatus type, schema comment, and live data are aligned.</done>
</task>

</tasks>

<verification>
1. D1 audit query was executed against remote database
2. ApplicationStatus type matches verified database values
3. Schema comment is updated and accurate
4. No data was modified without audit confirmation
5. TypeScript compiles cleanly
</verification>

<success_criteria>
Application status values shown in the UI match the values stored in the database schema, with existing live data audited and normalized before any constraint is added.
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-bugs-test-infrastructure/01-03-SUMMARY.md`
</output>
